---
title: "Modelagem com utilização do método dos mínimos quadrados"
author: "José Roberto Sobrinho Lima"
date: "24 de novembro de 2016"
fontsize: 12 pt
output: pdf_document
---
***
##1. Introdução  

O intuito deste trabalho é aplicar sobre uma determinada série temporal o 
**método dos mínimos quadrados**. Essa técnica é uma modelagem baseada em 
regressão, que procura estimar os valores da série sob análise
caracterizando tendência $T(t)$ e sazonalidade $S(t)$ de forma bem definida:
a tendência é modelada como um polinômio de grau arbitrário \textit{m}
definido por $T(t)=\sum_{j=0}^{m} \beta_{j}t^{j}$; e a sazonalidade, como
apresentando comportamento determinístico (ou seja, que pode ser previsto
perfeitamente a partir de meses anteriores) definida por
$S(t)=\sum_{j=1}^{12} \alpha_{j}d_{jt}$.  

Esses fatores limitam a capacidade de aproximação das séries estimadas,
tanto o modelo para os valores observados quanto o modelo para os valores
previstos. No primeiro caso, o fator limitante é a definição de uma
sazonalidade determinística, uma vez que não corresponde tão bem ao
comportamente de série não estacionárias (como a que estamos analisando).
No segundo caso, a limitação ocorre em virtude de aproximarmos a tendência
por um polinômio: embora ele possa ajustar-se bem ao conjunto de valores
observados, extrapolações futuras ou previsões possivelmente não serão tão
boas.  

##2. Objetivos  

###2.1. Objetivo Geral  

O escopo principal do trabalho é analisar o grau de proximidade de uma série
estimada mediante aplicação do **método dos mínimos quadrados** sobre uma
série original. Por _grau de proximidade_, entendemos tanto o resíduo $a(t)$
dos dados observados, quanto o _erro quadrático médio_ dos dados de
previsão.  

###2.2. Objetivos Específicos  

(a) Implementação do **método dos mínimos quadrados** apenas utilizando
comandos e funções básicas. Ou seja, sem o auxílio de recursos de funções e
rotinas pré-definidas de _toolboxs_ consolidadas.

(b) Apresentação dos dados obtidos mediante estruturas reutilizáveis
(_funções_) baseadas em parâmetros variados (grau da tendência polinomial e
quantidade de anos a serem previstos).  

##3. Justificativa  

É preciso definir critérios quantitativos para aferir o quão boa é uma
determinada modelagem de dados para aproximar os valores reais. Destarte,
os dois conjuntos de dados a seguir satisfazem a exigência de medidas
quantitativas para o que chamamos de _grau de proximidade_ entre o modelo
estimador e a série analisada.  

São elas: (1) o resíduo $a(t)$ das amostras observadas, que corresponde a
uma componente aleátoria de média zero e variância constante
$\sigma_{a}^{2}$ e (2) o _erro quadrático médio_ das amostras de previsão.  

Ademais, sobre a não utilização de _toolboxs_ com funções e rotinas
pré-definidas, existem inúmeras vantagem em desenhar um algoritmo utilizando
somente comandos e funções básicas, uma delas é conhecer os mecanismos
internos do método mais a fundo, o que nos permite avaliar criticamente as
limitações da própria técnica.  

Por fim, cabe rassaltar que a apresentação dos dados obtidos mediante
_funções_ definidas pelo usuário, que são estruturas reutilizáveis,
facilitam aplicações do algoritmo em sequência, sob variadas condições, que
se baseiam em parâmetros como o grau do polinômio que modela a tendência e
o número de anos sobre os quais serão feitas previsões.  

##4. Metodologia  

A aplicação desenvolvida neste trabalho utilizou uma série temporal que 
indica mensalmente a quantidade, em milhares, de homens jovens 
desempregados nos Estado Unidos, com idades de 16 a 19 anos, entre janeiro 
de 1948 e dezembro de 1981.  

Os dados foram obtidos no site [DataMarket][1], e foram salvos em um 
repositório público do [GitHub][2] para facilitar seu processamento no
código-fonte [projetoTS.R][3] que apresentaremos em pormenores no tópico
seguinte, em _**Resultados**_.  

##4. Resultados  

O código-fonte desenvolvido neste trabalho é apresentado a sequir.  

```{r setoptions, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE, results = "hide")
```

```{r beging}
#Definindo a biblioteca e os pacotes não padrões a serem utilizados.
.libPaths(
      "C:/Users/JoséRoberto/AppData/Roaming/SPB_16.6/R/win-library/3.2")
library(ggplot2)

#Caso necessário, o arquivo "dataMU.csv" é baixado.
urlFile <-
      c("https://raw.githubusercontent.com/JsRoberto/MU/master/dataMU.csv")
localFile <- c("./dataMU2.csv")

if (!exists(localFile)) {
      download.file(urlFile, localFile)
}

#A série temporal obtida é armazenada na variável "Z"
dataMU <- read.csv("./dataMU.csv", header = FALSE)
Z <<- ts(dataMU, start = c(1948,1), frequency = 12)
```

Esta primeira parte do código fonte diz respeito principalemnte ao
estabelecimento da série temporal utilizada.  

A parte seguinte é a principal do algoritmo, apresentando as três funções
definidas pelo programador. Elas aplicam o _**método dos mínimos quadrados**_,
geram os gráficos a partir dos parâmetros obtidos e calculam o 
**erro quadrático médio** da previsão (_MMQz()_, _plotz()_ e _EQM()_,
respectivamente). Mais detalhes estão presentes nos comentários do decorrer
do código.

```{r functions}
#A função "MMQz()" tem o objetivo de gerar o data.frame "dataMU", que apre-
#senta dados de modelagem da série "Z" obtidos mediante o método dos míni-
#mos quadrados. Entre os quais, temos: (1) série "Zest" que se aproxima de
#"Z", (2) tendência polinomial "Tt" de ordem "pol.order", (3) sazonalidade
#determinística "St", (4) resíduo "at" entre "Zest" e "Z". 
#Além disso, outros parâmetros também são gerados, ligados diretamente aos
#"anos.prev", que indica quantos anos finais da série a modelagem tentará
#prever.
MMQz <- function(Z, pol.order, anos.prev) {
      #Abaixo, são calculados os parâmetros que irão indicar qual subcon-
      #junto de "Z" será utilizado na modelagem e qual seré utilizdo para
      #previsão.
      idx1 <<- 1
      idx2 <<- length(Z)-12*anos.prev
      idx3 <<- length(Z)
      ap <<- anos.prev
      Zoriginal1 <- Z[idx1:idx2]
      Zoriginal2 <- Z[(idx2+1):idx3]
      N <- length(Zoriginal1) 
      anos <- N/12
      
      #Obtenção das matrizes "mT1" e "mT2".
      matrixT <- function(inc, fim, pol.order) {
            expp <<- NULL
            #A função "lst2vct()" transforma uma lista de vetores em um
            #único vetor
            lst2vct <- function(lst) {
                  vct <- vector()
                  for (k in 1:length(lst)) {
                        vct <- c(vct, lst[[k]])
                  }
                  vct
            }
            listT <- tapply(rep(inc:fim, pol.order+1),
                            gl(pol.order+1, fim-inc+1),
                            function(x) {
                                  if (is.null(expp)) {
                                        expp <<- 0
                                  } else expp <<- expp + 1
                                  x^expp
                            })
            vectT <- lst2vct(listT)
            mT <- matrix(vectT, fim-inc+1, pol.order+1)
            mT
      }
      mT1 <- matrixT(idx1, idx2, pol.order)
      mT2 <- matrixT(idx2+1, idx3, pol.order)
      
      #Obtenção das matrizes "mD1" e "mD2".
      mD1 <- mD2 <- mDaux <- rbind(diag(rep(1,11)), rep(-1,11))
      for(i in 1:(anos-1)) mD1 <- rbind(mD1,mDaux)
      for(i in 1:(anos.prev-1)) mD2 <- rbind(mD2,mDaux)
      
      #Obtenção da matriz "X" e da estimador de mínimos quadrados "gamma".
      X <- cbind(mT1, mD1)
      gamma <- chol2inv(chol(t(X)%*%X))%*%t(X)%*%Zoriginal1
      beta <- gamma[1:(pol.order+1)]
      alpha <- gamma[-(1:(pol.order+1))]
      
      #Os dados que serão armazenados em "dataMU" possuem tamanhos diferen-
      #tes, por isso precisam ser preenchidos por missing values ou NAs.
      Zprevisto <- mT2%*%beta + mD2%*%alpha
      Zprevisto <- c(rep(NA, N), Zprevisto)
      Zoriginal1 <- c(Zoriginal1, rep(NA, anos.prev*12))
      Zoriginal2 <- c(rep(NA, N), Zoriginal2)

      #Obtenção da série estimada "Zest", da tendência polinomial "Tt", da
      #sazonalidade determinística "St" e do resíduo "at".
      Zestimado <- c(X%*%gamma, rep(NA, anos.prev*12))
      Tt <- c(mT1%*%beta, rep(NA, anos.prev*12))
      St <- c(mD1%*%alpha, rep(NA, anos.prev*12))
      at <- Zoriginal1 - Zestimado
      
      #Finalmente, os dados são armazenados no data frame "dataMU". 
      dataMU <<- data.frame(Zorg1 = Zoriginal1, Zorg2 = Zoriginal2,
                            Zest = Zestimado, Zprev = Zprevisto,
                            Tt = Tt, St = St, at = at, t = 1:length(Z))
}

#A função "plotz()" produz quatro objetos gráficos, que plotam as caracte-
#rísticas do data.frame "dataMU".
plotz <- function() {
      #A variável abaixo modifica configuração de protagem padrão da bi-
      #blioteca "ggplot2".
      mytheme <- theme(plot.title=element_text(face="bold", size="14",
                                               color="brown"),
                       axis.title=element_text(face="bold", size=10,
                                               color="brown"),
                       axis.text=element_text(face="bold", size=9,
                                              color="darkblue"),
                       panel.background=element_rect(fill="white",
                                                     color="darkblue"),
                       panel.grid.major.x=element_line(color="grey",
                                                       linetype=1),
                       panel.grid.minor.x=element_line(color="grey",
                                                       linetype=2),
                       panel.grid.minor.y=element_blank())
      
      #O objeto "p1" plota a série original "Zorg1" e a série estimada
      #"Zest".
      p1 <<- ggplot(dataMU[idx1:idx2,], aes(x = t, y = Zorg1)) + 
             geom_line(color = "blue3", size = 1.1) + 
             geom_line(mapping = aes(y = Zest), color = "red3",
                       size = 1.1) +
             scale_x_continuous(breaks = seq(12, idx2, by = 24),
                                labels = seq(start(Z)[1], end(Z)[1]-ap,
                                             by = 2)) +
             labs(title = paste("American male unemployment (16-19 years)",
                                paste0("1948-", end(Z)[1] - ap)),
                  x = "Months (December)", y = "Unemployers (1000s)") +
             mytheme
      
      #O objeto "p2" plota a série original "Zorg1", tendência "Tt" e sazo-
      #nalidade "St".
      p2 <<- ggplot(dataMU[idx1:idx2,], aes(x = t, y = Zorg1)) +
             geom_line(color = "blue3", size = 1.1) + 
             geom_line(mapping = aes(y = St), color = "red3", size = 1.1) +
             geom_line(mapping = aes(y = Tt), color = "green3",
                       size = 1.1) +
             scale_x_continuous(breaks = seq(12, idx2, by = 24),
                                labels = seq(start(Z)[1], end(Z)[1]-ap,
                                             by = 2)) +
             labs(title = paste("American male unemployment (16-19 years)",
                                paste0("1948-", end(Z)[1] - ap)),
                  x = "Months (December)", y = "Unemployers (1000s)") +
             mytheme
      
      #O objeto "p3" plota o resíduo "at" e sua média, sendo obtido pela
      #diferença entre a série original "Zorg1" e a série estimada "Zest".
      p3 <<- ggplot(dataMU[idx1:idx2,], aes(x = t, y = at)) +
             geom_line(color = "blue3", size = 1.1) +
             geom_line(mapping = aes(y = mean(at)),
                       color = "red3", lty = "dashed", size = 1.1) +
             scale_x_continuous(breaks = seq(12, idx2, by = 24),
                                labels = seq(start(Z)[1], end(Z)[1]-ap,
                                             by = 2)) +
             labs(title = paste("American male unemployment (16-19 years)",
                                paste0("1948-", end(Z)[1] - ap)),
                  x = "Months (December)", y = "Residue a(t)") + 
             mytheme
      
      #O objeto "p4" plota a séria original "Zorg2" e a série de previsão
      #"Zprev".
      p4 <<- ggplot(dataMU[(idx2+1):idx3,], aes(x = t, y = Zorg2)) +
             geom_line(color = "blue3", size = 1.1) +
             geom_line(mapping = aes(y = Zprev), color = "green3",
                       size = 1.1) +
             scale_x_continuous(breaks = seq(idx2 + 1, idx3, by = 2),
                                labels = rep(c("Jan","Mar","May","Jul",
                                               "Sep","Nov"), ap)) +
             labs(title = paste("Forcasting U.S. male unemployment",
                                paste0("(16-19 years) ", end(Z)[1]-ap+1,
                                       "-1981")),
                  x = "Months (All)", y = "Unemployers (1000s)") +
             mytheme
}

#A função "EMQ()" aplica o erro quadrático médio sobre a diferença entre
#a série original "Zorg2" e a série de previsão "Zprev". 
EQM <- function() {
      erro <- dataMU$Zorg2 - dataMU$Zprev
      mse <- mean(erro^2, na.rm = TRUE)
      mse
}
```

Definidas as funções que realizarão o processamento, agora elas serão
aplicadas considerando tendências polinomiais de diferentes ordens e
considerando períodos de previsão variáveis para aplicação da modelagem.  

```{r graph1, results = "hold", fig.height = 4, fig.align = "center"}
#Aplicação de uma tendência linear (pol.order = 1) e previsão para 2 anos
#(anos.prev = 2).
MMQz(Z, 1, 2)
plotz()
p1; p2; p3; p4
```

O erro quadrático médio calculado para esta primeira aplicação utiliza os
dados plotados acima, no último gráfico. O seu valor é  

```{r results = "markup"} 
EQM()
```  

```{r graph2, results = "hold", fig.height = 4, fig.align = "center"}
#Aplicação de uma tendência quadrática (pol.order = 2) e previsão para 3 
#anos (anos.prev = 3).
MMQz(Z, 2, 3)
plotz()
p1; p2; p3; p4
```

O erro quadrático médio calculado para esta segunda aplicação utiliza os
dados plotados acima, no último gráfico. O seu valor é  

```{r results = "markup"} 
EQM()
```  

```{r graph3, results = "hold", fig.height = 4, fig.align = "center"}
#Aplicação de uma tendência de polinômio do 5º grau (pol.order = 5) e pre-
#visão para 3 anos (anos.prev = 3).
MMQz(Z, 5, 3)
plotz()
p1; p2; p3; p4
```

O erro quadrático médio calculado para esta terceira aplicação utiliza os
dados plotados acima, no último gráfico. O seu valor é  

```{r results = "markup"} 
EQM()
```

##5. Conclusão  

***
[1]: https://datamarket.com/data/set/22q4/monthly-us-male-16-19-years-unemployment-figures-thousands-1948-1981#!ds=22q4&display=line "DataMarket"

[2]: https://raw.githubusercontent.com/JsRoberto/MU/master/dataMU.csv "GitHub"

[3]: https://raw.githubusercontent.com/JsRoberto/MU/master/projetoTS.R "projetoTS.R"